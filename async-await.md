# Асинхронный код на Dart теперь выглядит проще с await/async

> Это свободный перевод статьи [Dart Language Asynchrony Support: Phase 1](https://www.dartlang.org/articles/await-async/), написанной Gilad Bracha.

В Dart появились новые возможности для поддержки асинхронного программирования. В этой статье мы обсудим основные: `await`-выражения и `async`-методы.

> **Примечание**
>
> Возможности, описанные в этой статье еще находятся в разработке, из-за чего не все части соответствуют спецификации. Перед тем, как использовать описанные далее возможности нужно импортировать пакет [dart:async](https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-async). В планах перенос `Future` в `dart:core`, чтобы сделать его доступным повсеместно.

## Async-функции

`async`-функции - это функции, тело которых помечено модификатором `async`

```dart
foo() async => 42;
```

Кода вызывается такая функция, она сразу же возвращает `Future`, а тело функции выполняется позже. Когда функция выполнится, то `Future`, которое было возвращено при вызове, будет содержать результат работы функции, вне зависимости от того, успешно была выполнена функция, или была какая-то ошибка. В примере выше, при вызове функции `foo()` она вернет `Future`. А `Future` будет содержать число `42`.

Вот как написать аналог этой функции без модификатора `async`:

```dart
foo() => new Future(() => 42);
```

Модификатор `async` позволяет меньше писать шаблонного кода, но реальная его польза в том, что он позволяет использовать выражение `await` внутри функции, что скоро мы и увидим. Позже мы вернемся к функциям `async` для более полного их понимания.

## Выражения `await`

Выражение `await` позволяет писать асинхронный код так, будто он синхронный. Например, у нас есть переменная `myFile`, которая представляет файл. (Для более подробной информации по работе с файлами изучите класс [File](https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-io.File) и пакета [dart:io](https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-io)). И нам нужно скопировать этот файл в новое место `newPath`, объявленному так:

```dart
String newPath = '/some/where/out/there';
```

И затем мы хотим проверить, что файл был скопирован куда надо:

```dart
myFile.copy(newPath).path == newPath;
```

Но это не сработает. Т.к. I/O API Dart асинхронное, то операция копирования отдает `Future`, и мы не можем обратиться к `path` таким способом. Мы должны передать `callback` в `then()` и уже там проверить путь:

```dart
myFile.copy(newPath).then((f) => f.path == newPath);
```

Это немного громоздко. В реальности нам просто нужно дождаться выполнения асинхронной операции, получить от нее результат, и потом свериться. Выражение `await` позволяет это сделать:

```dart
(await myFile.copy(newPath)).path == newPath;
```

Когда выражение `await` запускается, то оно вызывает `myFile.copy()` и получает `Future`. Выполнение приостанавливается, пока `Future` не выполнится. После того, как `Future` будет содержать результат, выполнение возобновится. Значение выражения `await` - результат `Future`, в нашем случае это файл. Теперь мы можем обратиться к `path` и сравнить его с `newPath`.

Выражение `await` имеет следующую форму:

```dart
await e
```

где *e* - это унарная операция. Обычно *e* это асинхронная функция, возвращающая `Future`. `await` принимает значение из *e*, затем приостанавливает выполнение функции, в которой она содержится до тех пор, пока значение не будет готово - обычно, пока `Future` не будет содержать результат. Результат `await` - это результат `Future`.

Если `Future` выполняется с ошибкой, то `await` бросит такую же ошибку, что упрощает обработку исключений в асинхронном коде.

Что если *e* вернет не `Future`? `await` будет ждать в любом случае (технически, результат будет обернут в `Future`, а затем `await` подождет его выполнения). Это одно из отличий реализации такого поведения между Dart и другими языками. В Dart `await` всегда ждет. Это делает поведение более предсказуемым. В частности, если у нас есть цикл с `await` внутри, то мы можем быть полностью уверены в том, что подождем выполнения выражения на каждой итерации.

Что есть *e* внутри бросит исключение? (Заметим, что это не то же самое, что завершение `Future` с ошибкой). Брошенное исключение будет обернуто во `Future` и выполнение приостановится. Когда выполнение будет возобновлено, то будет выброшено исключение. И снова предсказуемое поведение.

Последнее, но важное замечание: использовать выражение `await` можно только внутри `async`-функций. Если мы попробуем использовать `await` в обычных функциях, то получим ошибку компиляции.

## Async-функции - продолжение

Теперь, когда мы понимаем, как работает выражение `await`, вернемся снова к `async`-функциям для того, чтобы закрыть некоторые важные моменты.

Первое - модификатор идет между объявлением функции и ее телом. Мы можем написать `foo()` так:

```dart
foo() async { 
  return 42; 
}
```

Модификатор находится перед `=>` или фигурной скобкой, открывающей тело функции.

Модификатор не является частью объявления функции, он просто поясняет реализацию функции. Вызов такой функции ничем не отличается от вызова обычной функции.

Модификатор `async` не требует каких-то изменений при объявлении типа возвращаемого функцией значения по той же причине. Тем не менее, реальный тип возвращаемого значения изменяется. Например, если объявлено, что функция возвращает `int`, и она помечена как `async`, то в результате вызова этой функции будет отдано `Future`. Внутри `async`-функций оператор возврата работает немного иначе, чем в обычной функции. В `asycn`-функции `return` возвращает `Future`, результатом которого будет значение выражения, находящегося после `return`.

Если внутри `aync`-функции будет брошено исключение, то Future будет завершено с ошибкой.

Если результат выражения типа `T`, то функция должна возвращать `Future<T>` (или его супертип). В противном случае будет показано предупреждение. Функции в наших примерах не указывают тип возвращаемого значения, из-за чего считается, что тип возвращаемого значения - `dynamic` - именно поэтому мы не получаем предупреждений при их запуске.

Если внутри функции возвращается `Future<T>`, то **не нужно** указывать, что функция отдает `Future<Future<T>>`, вместо этого просто указываем `Future<T>`. В библиотеке `async` `Future` вложенные внутрь других `Future` были устранены, т.к. с ними нечего делать, кроме как ждать, пока выполнится вложенное `Future`. Т.е. Если мы отдаем `Future<Future<T>>`, то нам только и останется, что ждать, пока выполнится вложенный `Future`, а внешняя *"обертка"* нам и не нужна. Именно поэтому, если наш метод уже отдает `Future<T>`, то после того, как мы пометим его модификтором `async` **не нужно** писать, что он отдает `Future<Future<T>>`, а нужно оставить `Future<T>`.

Напоследок заметим, что `async`-функции в Dart всегда асинхронны. Это не похоже на подобные функции в других языках, где в некоторых случаях функции могут быть выполнены синхронно. In Dart, you know that every part of an async function is executing after the call that invoked it has returned to the caller.

## Объединяем все вместе

Давайте разберем пример, который включает все, о чем мы здесь говорили. Пусть это будет запуск простой анимации, которая обновляет экран на каждом кадре.

Без `async` и `await` код будет выглядеть примерно так:

```dart
import "dart:html"

main() {
  var context = querySelector("canvas").context2D;
  var running = true;    // Установить false для остановки

  tick(time) {
    context.clearRect(0, 0, 500, 500);
    context.fillRect(time % 450, 20, 50, 50);

    if (running) window.animationFrame.then(tick);
  }

  window.animationFrame.then(tick);
}
```

Код не так сложен, но и не слишком прост. Мы делаем кадр; когда кадр готов, то мы вызваем функцию `tick()`, которая делает новый кадр (если анимация не остановлена) и передает себя в качестве обработчика, зацикливая процесс.

А вот как можно переписать этот же код с использованием `async` и `await`:

```dart
import "dart:html";

main() async {
  var context = querySelector("canvas").context2D;
  var running = true;    // Установить false для остановки

  while (running) {
    var time = await window.animationFrame;
    context.clearRect(0, 0, 500, 500);
    context.fillRect(time % 450, 20, 50, 50);
  }
}
```

Тут все выглядит проще и не нуждается в особых пояснениях. Пока анимация запущена, мы работаем с кадром. Выбор за вами.